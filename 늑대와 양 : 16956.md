# 늑대와 양 : 16956

------

## 문제

크기가 R×C인 목장이 있고, 목장은 1×1 크기의 칸으로 나누어져 있다. 각각의 칸에는 비어있거나, 양 또는 늑대가 있다. 양은 이동하지 않고 위치를 지키고 있고, 늑대는 인접한 칸을 자유롭게 이동할 수 있다. 두 칸이 인접하다는 것은 두 칸이 변을 공유하는 경우이다.

목장에 울타리를 설치해 늑대가 양이 있는 칸으로 갈 수 없게 하려고 한다. 늑대는 울타리가 있는 칸으로는 이동할 수 없다. 울타리를 설치해보자.

## 입력

첫째 줄에 목장의 크기 R, C가 주어진다.

둘째 줄부터 R개의 줄에 목장의 상태가 주어진다. '`.`'는 빈 칸, '`S`'는 양, '`W`'는 늑대이다.

## 출력

늑대가 양이 있는 칸으로 갈 수 없게 할 수 있다면 첫째 줄에 1을 출력하고, 둘째 줄부터 R개의 줄에 목장의 상태를 출력한다. 울타리는 '`D`'로 출력한다. 울타리를 어떻게 설치해도 늑대가 양이 있는 칸으로 갈 수 있다면 첫째 줄에 0을 출력한다.

## Think

>+ 울타리의 최소 개수를 구하는 문제가 아니다.
>+ 울타리에 대한 제한 조건이 존재하지 않는다.
>+ 그러면 인접할 양과 늑대가 인접할 때를 제외하고 모두 울타리로 채우자.
>+ flag를 두고 인접하는 경우가 한 가지라도 존재할 경우 무조건 0을 출력

## code

```python
# 늑대와 양
import sys

R, C = map(int, sys.stdin.readline().split())
myMap = [list(sys.stdin.readline().strip()) for _ in range(R)]
dx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]
flag = 0
for i in range(R):
    for j in range(C):
        if myMap[i][j] == 'W':
            for a in range(4):
                ni, nj = i + dx[a], j + dy[a]
                if ni < 0 or nj < 0 or ni == R or nj == C:
                    continue
                elif myMap[ni][nj] == 'S':
                    flag=1
        elif myMap[i][j] == 'S':
            continue
        else:
            myMap[i][j] = 'D'

if flag == 1:
    print('0')
else:
    print('1')
    for i in myMap:
        print(''.join(i))
```



## 느낀점

>처음에는 울타리 조건을 맞추어야 하는 줄 알고 어떻게 해야할지 막막해다...
>
>알고보니.. 인접할 때를 제외하고는 울타리로 채우면 끝나는 문제..